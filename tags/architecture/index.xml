<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>architecture on Thỉnh thoảng đôi lời</title><link>/tags/architecture/</link><description>Recent content in architecture on Thỉnh thoảng đôi lời</description><generator>Hugo -- gohugo.io</generator><language>vi-vn</language><copyright>ducnguyen96</copyright><lastBuildDate>Mon, 13 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Microservices với NodeJS phần 8 - Authentication Strategies and Options</title><link>/posts/backend/microservices-with-node-p8/</link><pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p8/</guid><description>Fundamential Authentication Strategies 1. Sync Communication 1.1. Gateway Cả 2 cách trên đều có nhược điểm của sync communication
2. Mỗi service đều có thể tự authenticate Điểm cộng: không phụ thuộc vào bất cứ service nào khác. Điểm trừ: duplicate authentication cho mọi service; một số issue khác mà chúng ta sẽ nói ngay ở phần dứoi 2. Huge Issues with Authentication Strategies Như đã nói ở trên thì chúng ta sẽ chắc chắn sẽ không dùng cách 1 và 1.</description></item><item><title>Microservices với NodeJS phần 7 - Database Management and Modeling</title><link>/posts/backend/microservices-with-node-p7/</link><pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p7/</guid><description>Createing Databases in Kubernetes npm i mongoose # auth-mongo-depl.yml apiVersion: apps/v1 kind: Deployment metadata: name: auth-mongo-depl namespace: ingress-nginx spec: replicas: 1 selector: matchLabels: app: auth-mongo template: metadata: labels: app: auth-mongo spec: containers: - name: auth-mongo image: mongo --- apiVersion: v1 kind: Service metadata: name: auth-mongo-srv namespace: ingress-nginx spec: selector: app: auth-mongo ports: - name: db protocol: TCP port: 27017 targetPort: 27017 Creating Databases in Kubernetes npm i @types/mongoose // index.ts import mongoose from &amp;#34;mongoose&amp;#34;; const start = async () =&amp;gt; { try { await mongoose.</description></item><item><title>Microservices với NodeJS phần 6 - Response Normalization Strategies</title><link>/posts/backend/microservices-with-node-p6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p6/</guid><description>Creating Route Handlers src/ ├─ routes/ │ ├─ signup.ts │ ├─ signin.ts │ ├─ signout.ts │ ├─ current-user.ts // current-user.ts import express from &amp;#34;express&amp;#34;; const router = express.Router(); router.get(&amp;#34;/api/users/currentuser&amp;#34;, (req, res) =&amp;gt; { res.send(&amp;#34;Hi there !&amp;#34;); }); export { router as currentUserRouter }; Tương tự với 3 routes kia
// signup.ts import express from &amp;#34;express&amp;#34;; const router = express.Router(); router.post(&amp;#34;/api/users/signup&amp;#34;, (req, res) =&amp;gt; { res.send(&amp;#34;Hi there !&amp;#34;); }); export { router as signupRouter }; // index.</description></item><item><title>Microservices với NodeJS phần 5 - Architecture of Multi-Service Apps</title><link>/posts/backend/microservices-with-node-p5/</link><pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p5/</guid><description>Big Tickets Items Trước khi đi vào phân tích app tiếp theo của chúng ta, hãy cùng điểm qua một số bài học từ app trước. Một trong những khó khăn lớn nhất khi thực hiện kiến trúc microservice là data. Có nhiều cách giao tiếp giữa các services nhưng chúng ta sẽ tập trung vào async communication, vì các lợi ích nó mang lại cũng như sync communication thì dễ dàng để implement và không có gì nhiều để nói.</description></item><item><title>Microservices với NodeJS phần 4 - Điều phối services với Kubernetes</title><link>/posts/backend/microservices-with-node-p4/</link><pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p4/</guid><description>Installing Kubernetes Cài đặt theo ở đây nhé.
Lưu ý: Sau khi cài đặt kubectl, để chạy 1 cluster trên máy local của bạn thì ta sẽ sử dụng thêm 1 tool gọi là minikube. Bạn đọc tìm hiểu thêm ở đây
A Quick Kubernetes Tour Những thuật ngữ quan trọng trong Kubernetes Kubernetes Cluster bao gồm một hoặc nhiều nodes (mỗi node là một máy ảo) và 1 Master để quản lý các nodes.</description></item><item><title>Microservices với NodeJS phần 3 - Running Services With Docker</title><link>/posts/backend/microservices-with-node-p3/</link><pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p3/</guid><description>Vậy là mini app của chúng ta đã hoàn tất, bây giờ chúng ta bắt đầu nghĩ đến việc deploy nó online để người khác có thể truy cập vào.
Trước tên hay xem lại app của chúng ta đang được thực thi như thế nào trên local. Hiện tại thì mỗi service đều chạy trên 1 port cụ thể và có thể giao tiếp với nhau qua axios. Vậy làm sao ta có thể thay đổi 1 chút và deploy toàn bộ app này?</description></item><item><title>Microservices với NodeJS phần 2 - một mini-microservices app</title><link>/posts/backend/microservices-with-node-p2/</link><pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p2/</guid><description>Ở bài trước thì chúng ta đã thấy một vài notes về cách chúng ta xử lý vấn đề giao tiếp giữa các microservices, bây giờ thì hãy bắt đầu viết một vài dòng code nào 😄.
Giờ ta sẽ xem qua mock-up của app mà chúng ta sẽ build để có hiểu hơn về async communication. Dưới đây là một vài chú ý về project tiếp theo chúng ta sẽ build.</description></item><item><title>Microservices với NodeJS phần 1 - những ý tưởng cơ bản về microservices</title><link>/posts/backend/microservices-with-node/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node/</guid><description>What is a microservice ? Để trả lời câu hỏi này thì trước hết ta sẽ review lại cách hoạt động của Monolithic Server.
Chúng ta có toàn bộ code nằm trong 1 single code base và chúng ta deploy như 1 unit.
Flow của 1 request sẽ như sau: Đầu tiên thì có thể đi qua 1 số middleware, sau đó qua 1 số router, router sẽ inspect request đó và gửi đến feature nhất định để xử lý, chẳng hạn đọc hoặc ghi dữ liệu ở database sau cùng là gửi response lại cho người tạ request.</description></item><item><title>Microservices vs Monoliths</title><link>/posts/backend/microservices-vs-monolith/</link><pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-vs-monolith/</guid><description>Trong xu hướng mới nổi của microservices thì các cuộc tranh luận về nó và Monolith là không thể tránh khỏi. Kiến trúc microservices cung cấp những lợi ích như khả năng mở rộng ,tính linh thoạt và là một cách hiệu quả về chi phí đối với những ứng dụng nhiều tính năng. Những gã khổng lồ về công nghệ như Netflix, Amazon và Oracle thường triển khai kiến trúc microservice trong 1 hoặc nhiều ứng dụng.</description></item></channel></rss>