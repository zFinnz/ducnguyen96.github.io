<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>backend on Thỉnh thoảng đôi lời</title><link>/categories/backend/</link><description>Recent content in backend on Thỉnh thoảng đôi lời</description><generator>Hugo -- gohugo.io</generator><language>vi-vn</language><copyright>ducnguyen96</copyright><lastBuildDate>Mon, 20 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="/categories/backend/index.xml" rel="self" type="application/rss+xml"/><item><title>Microservices với NodeJS phần 17 - Understanding Event Flow</title><link>/posts/backend/microservices-with-node-p17/</link><pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p17/</guid><description>Creating the Events // common/src/events/subjects.ts export enum Subjects { TicketCreated = &amp;#34;ticket:created&amp;#34;, TicketUpdated = &amp;#34;ticket:updated&amp;#34;, OrderCreated = &amp;#34;order:created&amp;#34;, OrderCancelled = &amp;#34;order:cancelled&amp;#34;, } // order-created-event.ts export interface OrderCreatedEvent { subject: Subjects.OrderCreated; data: { id: string; status: OrderStatus; userId: string; expiresAt: string; ticket: { id: string; price: number; }; }; } // order-cancelled-event.ts export interface OrderCancelledEvent { subject: Subjects.OrderCancelled; data: { id: string; ticket: { id: string; }; }; } // index.ts export * from &amp;#34;.</description></item><item><title>Microservices với NodeJS phần 16 - Cross-Service Data Replication In Action</title><link>/posts/backend/microservices-with-node-p16/</link><pubDate>Fri, 17 Sep 2021 02:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p16/</guid><description>The Orders Service Skaffolding the Orders Service Create Order Service Copy .dockerignore, Dockerfile, tsconfig.json, package.json, package-lock.json from tickets service Update package name Copy app.ts, index.ts, nats-wrapper.ts npm install Create orders-depl.yml
apiVersion: apps/v1 kind: Deployment metadata: name: orders-depl namespace: ingress-nginx spec: replicas: 1 selector: matchLabels: app: orders template: metadata: labels: app: orders spec: containers: - name: orders image: ducnguyen96/ticketing-orders env: - name: JWT_KEY valueFrom: secretKeyRef: name: jwt-secret key: JWT_KEY - name: MONGO_URI value: &amp;#34;mongodb://orders-mongo-srv:27017/orders&amp;#34; - name: NATS_CLIENT_ID valueFrom: fieldRef: fieldPath: metadata.</description></item><item><title>Microservices với NodeJS phần 15 - Managing a NATS Client</title><link>/posts/backend/microservices-with-node-p15/</link><pubDate>Fri, 17 Sep 2021 01:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p15/</guid><description>Publishing Ticket Creation Update NATS cho ticket service
npm update @ducnguyen96/ticketing-common // src/events/publishers/ticket-created-publisher.ts export class TicketCreatedPublisher extends Publisher&amp;lt;TicketCreatedEvent&amp;gt; { subject: Subjects.TicketCreated = Subjects.TicketCreated; } Publish event in create.ts when create ticket
// src/routes/create.ts await ticket.save(); await new TicketCreatedPublisher(client).publish({ id: ticket.id, title: ticket.title, price: ticket.price, userId: ticket.userId, }); NATS Client Singleton Cần connect đến NATS trước khi app.listen.
Remember Mongoose ? // src/nats-wrapper.ts import nats, { Stan } from &amp;#34;node-nats-streaming&amp;#34;; class NatsWrapper { private _client?</description></item><item><title>Microservices với NodeJS phần 14 - Connecting to NATS in Node JS</title><link>/posts/backend/microservices-with-node-p14/</link><pubDate>Fri, 17 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p14/</guid><description>Reusable NATS listeners // src/events/base-listener.ts abstract class Listener { abstract subject: string; abstract queueGroupName: string; private client: Stan; protected ackWait = 5 * 1000; abstract onMessage(data: any, msg: Message): void; constructor(client: Stan) { this.client = client; } subscriptionOptions() { return this.client .subscriptionOptions() .setDeliverAllAvailable() .setManualAckMode(true) .setAckWait(this.ackWait) .setDurableName(this.queueGroupName); } listen() { const subscription = this.client.subscribe( this.subject, this.queueGroupName, this.subscriptionOptions() ); subscription.on(&amp;#34;message&amp;#34;, (msg: Message) =&amp;gt; { console.log(`Message received: ${this.subject}/ ${this.queueGroupName}`); const parsedData = this.parseMessage(msg); this.</description></item><item><title>Microservices với NodeJS phần 13 - NATS Streaming Server - An Event Bus Implementation</title><link>/posts/backend/microservices-with-node-p13/</link><pubDate>Thu, 16 Sep 2021 02:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p13/</guid><description>Creating a NATS Streaming Deployment # nats-depl.yml apiVersion: apps/v1 kind: Deployment metadata: name: nats-depl namespace: ingress-nginx spec: replicas: 1 selector: matchLabels: app: nats template: metadata: labels: app: nats spec: containers: - name: nats image: nats-streaming:0.22.1 args: [ &amp;#34;-p&amp;#34;, &amp;#34;4222&amp;#34;, &amp;#34;-m&amp;#34;, &amp;#34;8222&amp;#34;, &amp;#34;-hbi&amp;#34;, &amp;#34;5s&amp;#34;, &amp;#34;-hbt&amp;#34;, &amp;#34;5s&amp;#34;, &amp;#34;-hbf&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;-SD&amp;#34;, &amp;#34;-cid&amp;#34;, &amp;#34;ticketing&amp;#34;, ] --- apiVersion: v1 kind: Service metadata: name: nats-srv namespace: ingress-nginx spec: selector: app: nats ports: - name: client protocol: TCP port: 4222 targetPort: 4222 - name: minitoring protocol: TCP port: 8222 targetPort: 8222 Big Notes on NATS Streaming EventBus service hiện tại của chúng ta sử dụng express + axios Để giao tiếp với NATS thì ta sẽ sử dụng node-nats-steaming Để nhận được event từ eventbus thì service cần phải subscribe tới NATS EventBus service hiện tại của chúng ta lưu vào bộ nhớ và sẽ mất khi reset service NATS Streaming lưu tất cả events vào memory (mặc định) hoặc vào files, MySQL/PostGres DB Building a NATS Test Project npm init -y npm i node-nats-streaming ts-node-dev typescript @types/node // src/publisher.</description></item><item><title>Microservices với NodeJS phần 12 - CRUD Server Setup</title><link>/posts/backend/microservices-with-node-p12/</link><pubDate>Thu, 16 Sep 2021 01:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p12/</guid><description>Ticketing Service Project Setup Với tickets service thì ta sẽ copy từ auth service để tiết kiệm thời gian
1. make service folder mkdir tickets 2. copy same config Copy .dockerignore, Dockerfile, package-lock.json, package.json, tsconfig.json vào tickets
3. copy same code Copy src/test/*, src/app.ts, src/index.ts
4. update package name Updae package name in package.json
5. update code Update lại code vừa copy.
6. install dependencies npm install 7. Build image eval $(minikube docker-env) docker build -t ducnguyen96/ticketing-tickets .</description></item><item><title>Microservices với NodeJS phần 11 - Code Sharing and Reuse Between Services</title><link>/posts/backend/microservices-with-node-p11/</link><pubDate>Thu, 16 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p11/</guid><description>Chúng ta thấy những phần như Custom Error, Auth Middleware, Request Validation là những thành phần chung giữa các server nên ta sẽ tạo ra 1 package common và cài đặt package này cho những services cần thiết.
Options for Code Sharing Có một số cách để share code giữa các services như sau:
Copy Paste Cách này thì hẳn không ai muốn dùng rồi, vì khó có thể đồng bộ code mỗi khi cần thay đổi common.</description></item><item><title>Microservices với NodeJS phần 10 - Intergrating a Server-Side-Rendered React App</title><link>/posts/backend/microservices-with-node-p10/</link><pubDate>Wed, 15 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p10/</guid><description>Reminder on Server Side Rendering Basics of Next JS npm install react react-dom next Building a Next Image FROMnode:alpineWORKDIR/appCOPY package.json .RUN npm installCOPY . .CMD [&amp;#34;npm&amp;#34;, &amp;#34;run&amp;#34;, &amp;#34;dev&amp;#34;]# .dockerignorenode_modules.nextdocker build -t ducnguyen96/ticketing-client . Running Next in Kubernetes client-depl.yml
apiVersion: apps/v1 kind: Deployment metadata: name: client-depl namespace: ingress-nginx spec: replicas: 1 selector: matchLabels: app: client template: metadata: labels: app: client spec: containers: - name: client image: ducnguyen96/ticketing-client --- apiVersion: v1 kind: Service metadata: name: client-srv namespace: ingress-nginx spec: selector: app: client ports: - name: client protocol: TCP port: 3000 targetPort: 3000 skaffold.</description></item><item><title>Microservices với NodeJS phần 9 - Testing Isolated Microservices</title><link>/posts/backend/microservices-with-node-p9/</link><pubDate>Tue, 14 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p9/</guid><description>Scope of Testing Testing Goal Testing Architecture // app.ts import express from &amp;#34;express&amp;#34;; import { json } from &amp;#34;body-parser&amp;#34;; import { currentUserRouter } from &amp;#34;./routes/current-user&amp;#34;; import { signinRouter } from &amp;#34;./routes/signin&amp;#34;; import { signupRouter } from &amp;#34;./routes/signup&amp;#34;; import { signoutRouter } from &amp;#34;./routes/signout&amp;#34;; import { errorHandler } from &amp;#34;./middlewares/error-handler&amp;#34;; import { NotFoundEror } from &amp;#34;./errors/not-found-error&amp;#34;; import &amp;#34;express-async-errors&amp;#34;; import cookieSession from &amp;#34;cookie-session&amp;#34;; const app = express(); app.use(json()); app.set(&amp;#34;trust proxy&amp;#34;, true); // trust nginx app.</description></item><item><title>Microservices với NodeJS phần 8 - Authentication Strategies and Options</title><link>/posts/backend/microservices-with-node-p8/</link><pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p8/</guid><description>Fundamential Authentication Strategies 1. Sync Communication 1.1. Gateway Cả 2 cách trên đều có nhược điểm của sync communication
2. Mỗi service đều có thể tự authenticate Điểm cộng: không phụ thuộc vào bất cứ service nào khác. Điểm trừ: duplicate authentication cho mọi service; một số issue khác mà chúng ta sẽ nói ngay ở phần dứoi 2. Huge Issues with Authentication Strategies Như đã nói ở trên thì chúng ta sẽ chắc chắn sẽ không dùng cách 1 và 1.</description></item><item><title>Microservices với NodeJS phần 7 - Database Management and Modeling</title><link>/posts/backend/microservices-with-node-p7/</link><pubDate>Sun, 12 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p7/</guid><description>Createing Databases in Kubernetes npm i mongoose # auth-mongo-depl.yml apiVersion: apps/v1 kind: Deployment metadata: name: auth-mongo-depl namespace: ingress-nginx spec: replicas: 1 selector: matchLabels: app: auth-mongo template: metadata: labels: app: auth-mongo spec: containers: - name: auth-mongo image: mongo --- apiVersion: v1 kind: Service metadata: name: auth-mongo-srv namespace: ingress-nginx spec: selector: app: auth-mongo ports: - name: db protocol: TCP port: 27017 targetPort: 27017 Creating Databases in Kubernetes npm i @types/mongoose // index.ts import mongoose from &amp;#34;mongoose&amp;#34;; const start = async () =&amp;gt; { try { await mongoose.</description></item><item><title>Microservices với NodeJS phần 6 - Response Normalization Strategies</title><link>/posts/backend/microservices-with-node-p6/</link><pubDate>Sat, 11 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p6/</guid><description>Creating Route Handlers src/ ├─ routes/ │ ├─ signup.ts │ ├─ signin.ts │ ├─ signout.ts │ ├─ current-user.ts // current-user.ts import express from &amp;#34;express&amp;#34;; const router = express.Router(); router.get(&amp;#34;/api/users/currentuser&amp;#34;, (req, res) =&amp;gt; { res.send(&amp;#34;Hi there !&amp;#34;); }); export { router as currentUserRouter }; Tương tự với 3 routes kia
// signup.ts import express from &amp;#34;express&amp;#34;; const router = express.Router(); router.post(&amp;#34;/api/users/signup&amp;#34;, (req, res) =&amp;gt; { res.send(&amp;#34;Hi there !&amp;#34;); }); export { router as signupRouter }; // index.</description></item><item><title>Microservices với NodeJS phần 5 - Architecture of Multi-Service Apps</title><link>/posts/backend/microservices-with-node-p5/</link><pubDate>Fri, 10 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p5/</guid><description>Big Tickets Items Trước khi đi vào phân tích app tiếp theo của chúng ta, hãy cùng điểm qua một số bài học từ app trước. Một trong những khó khăn lớn nhất khi thực hiện kiến trúc microservice là data. Có nhiều cách giao tiếp giữa các services nhưng chúng ta sẽ tập trung vào async communication, vì các lợi ích nó mang lại cũng như sync communication thì dễ dàng để implement và không có gì nhiều để nói.</description></item><item><title>Microservices với NodeJS phần 4 - Điều phối services với Kubernetes</title><link>/posts/backend/microservices-with-node-p4/</link><pubDate>Thu, 09 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p4/</guid><description>Installing Kubernetes Cài đặt theo ở đây nhé.
Lưu ý: Sau khi cài đặt kubectl, để chạy 1 cluster trên máy local của bạn thì ta sẽ sử dụng thêm 1 tool gọi là minikube. Bạn đọc tìm hiểu thêm ở đây
A Quick Kubernetes Tour Những thuật ngữ quan trọng trong Kubernetes Kubernetes Cluster bao gồm một hoặc nhiều nodes (mỗi node là một máy ảo) và 1 Master để quản lý các nodes.</description></item><item><title>Microservices với NodeJS phần 3 - Running Services With Docker</title><link>/posts/backend/microservices-with-node-p3/</link><pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p3/</guid><description>Vậy là mini app của chúng ta đã hoàn tất, bây giờ chúng ta bắt đầu nghĩ đến việc deploy nó online để người khác có thể truy cập vào.
Trước tên hay xem lại app của chúng ta đang được thực thi như thế nào trên local. Hiện tại thì mỗi service đều chạy trên 1 port cụ thể và có thể giao tiếp với nhau qua axios. Vậy làm sao ta có thể thay đổi 1 chút và deploy toàn bộ app này?</description></item><item><title>Microservices với NodeJS phần 2 - một mini-microservices app</title><link>/posts/backend/microservices-with-node-p2/</link><pubDate>Tue, 07 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node-p2/</guid><description>Ở bài trước thì chúng ta đã thấy một vài notes về cách chúng ta xử lý vấn đề giao tiếp giữa các microservices, bây giờ thì hãy bắt đầu viết một vài dòng code nào 😄.
Giờ ta sẽ xem qua mock-up của app mà chúng ta sẽ build để có hiểu hơn về async communication. Dưới đây là một vài chú ý về project tiếp theo chúng ta sẽ build.</description></item><item><title>Microservices với NodeJS phần 1 - những ý tưởng cơ bản về microservices</title><link>/posts/backend/microservices-with-node/</link><pubDate>Sun, 05 Sep 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-with-node/</guid><description>What is a microservice ? Để trả lời câu hỏi này thì trước hết ta sẽ review lại cách hoạt động của Monolithic Server.
Chúng ta có toàn bộ code nằm trong 1 single code base và chúng ta deploy như 1 unit.
Flow của 1 request sẽ như sau: Đầu tiên thì có thể đi qua 1 số middleware, sau đó qua 1 số router, router sẽ inspect request đó và gửi đến feature nhất định để xử lý, chẳng hạn đọc hoặc ghi dữ liệu ở database sau cùng là gửi response lại cho người tạ request.</description></item><item><title>Microservices vs Monoliths</title><link>/posts/backend/microservices-vs-monolith/</link><pubDate>Tue, 31 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/backend/microservices-vs-monolith/</guid><description>Trong xu hướng mới nổi của microservices thì các cuộc tranh luận về nó và Monolith là không thể tránh khỏi. Kiến trúc microservices cung cấp những lợi ích như khả năng mở rộng ,tính linh thoạt và là một cách hiệu quả về chi phí đối với những ứng dụng nhiều tính năng. Những gã khổng lồ về công nghệ như Netflix, Amazon và Oracle thường triển khai kiến trúc microservice trong 1 hoặc nhiều ứng dụng.</description></item><item><title>Javascript in a nutshell</title><link>/posts/backend/javascript-in-a-nutshell/</link><pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/backend/javascript-in-a-nutshell/</guid><description>Do bài viết có rất nhiều mục và dài nên bạn đọc nhìn vào Table Of Content (TOC) ở side-bar bên phải để đọc mục mình quan tâm nhé.
Tham khảo: javascript.info
Variables var &amp;ldquo;var&amp;rdquo; không có block scope
if (true) { var test = true; // dùng &amp;#34;var&amp;#34; thay &amp;#34;let&amp;#34; } alert(test); // true, var không có block scope nên nó được kéo ra khỏi block scope. Nếu một block nằm trong 1 function thì var sẽ trở thành biến function-level</description></item><item><title>Authentication in a nutshell</title><link>/posts/backend/authentication-in-a-nutshell/</link><pubDate>Sun, 29 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/backend/authentication-in-a-nutshell/</guid><description>Như đã nói trong bài này, http không giữ trạng thái giữa 2 lần request vì vậy ví dụ sau khi đăng nhập sau, user đến một page nào đó cần xác minh chẳng hạn như setting thì user lại bị yêu cầu đăng nhập lần nữa. Nhưng với session hoặc token authentication thì server có thể nhận biết là user đã đăng nhập và nên được cấp quyền truy cập.</description></item><item><title>HTTP in a nutshell</title><link>/posts/backend/http-in-a-nutshell/</link><pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/backend/http-in-a-nutshell/</guid><description>Hypertext Transfer Protocol (HTTP) là một giao thức(protocol) thuộc lớp ứng dụng được thiết kế cho để thực hiện giao tiếp giữa web browsers và web servers, nhưng nó cũng được sử dụng cho nhiều mục đích khác. HTTP tuân theo mô hình client-server cổ điển, với một client open connection để tạo request, sau đó chờ cho đến khi nhận được response. HTTP là một giao thức không có trạng thái, nghĩa là server không dữ trạng thái giữa 2 lần requests.</description></item><item><title>Database indexing cơ bản</title><link>/posts/databases/database-indexing/</link><pubDate>Thu, 26 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/databases/database-indexing/</guid><description>Những kiến thức dưới đây sẽ áp dụng được với postgres còn những database khác thì mình không chắc nhé.
Row được lưu như thế nào ? Cấu trúc được sử dụng để lưu trữ 1 table là 1 heap file - list các page có fixed size (thường là 8Kb). Trong 1 table thì tất cả các page đều tương đương về mặt logic, nên 1 row cụ thể có thể được lưu trữ ở bất kỳ page nào.</description></item><item><title>Transaction in a nutshell</title><link>/posts/databases/transaction-in-a-nutshell/</link><pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/databases/transaction-in-a-nutshell/</guid><description>Transaction có thể được định nghĩa là 1 nhóm task. Một task đơn lẻ là 1 đơn vị xử lý mà không thể chia nhỏ hơn nữa.
Lấy một ví dụ đơn giản. Giả sử một nhân viên ngân hàng chuyển 500 triệu từ tài khoản A đến tài khoản B. Đây là một transaction đơn giản chứa những task sau đây.
A&amp;rsquo;s Account
Open_Account(A) Old_Balance = A.balance New_Balance = Old_Balance - 500 A.</description></item><item><title>ACID trong cơ sở dữ liệu</title><link>/posts/databases/acid-in-dbms/</link><pubDate>Tue, 24 Aug 2021 10:00:27 +0000</pubDate><guid>/posts/databases/acid-in-dbms/</guid><description>Transaction là một đơn vị logic nó thực hiện việc truy xuất và chỉnh sửa nội dung của database. Để duy trì tính thống nhất cả database trước và sau khi thực hiện transaction thì cần tuân theo một số tính chất và được viết tắt là ACID
Atomicity (/æt.əˈmɪs.ɪ.ti/) Yêu cầu transaction phải thực hiện 1 cách hoàn chỉnh hoặc là không thực hiện, chứ không có việc chỉ thực hiện 1 phần.</description></item><item><title>Cài đặt docker, nginx, cloudflare, tmate và deploy một web app hoàn toàn free trên raspberry pi</title><link>/posts/devops/cai-dat-docker-nginx-cloudflare-tmate-va-deploy-mot-web-app-hoan-toan-free-tren-raspberry-pi/</link><pubDate>Wed, 14 Jul 2021 08:23:27 +0000</pubDate><guid>/posts/devops/cai-dat-docker-nginx-cloudflare-tmate-va-deploy-mot-web-app-hoan-toan-free-tren-raspberry-pi/</guid><description>1. Cài đặt image cho Pi Cài đặt Raspbian bằng raspberry pi imager Lưu ý: Raspberry Pi chạy chip ARM và Raspbian ở kiến trúc arm/v7 32bit nên các cài đặt ở phía dưới đều phải dùng cho kiến trúc này.
2. Cài tmate để ssh Chúng ta dùng tmate bản static build arm/v7 32bit để có đầy đủ tính năng mới nhất như chạy foreground (-F).
wget https://github.com/tmate-io/tmate/releases/download/2.4.0/dbg-symbols-tmate-2.4.0-static-linux-arm32v7.tar.xz Đăng ký API key để có static IP và session name giống nhau cho mỗi lần đăng nhập vào con Pi.</description></item><item><title>Docker nền tảng</title><link>/posts/backend/docker-fundamentals/</link><pubDate>Thu, 08 Jul 2021 08:45:15 +0000</pubDate><guid>/posts/backend/docker-fundamentals/</guid><description>Ở chương trước ta đã hoàn thành build một web server trên 1 máy chủ thuê của AWS với 1 phiên bản nginx cụ thể và mọi thứ vẫn hoạt động hoàn hảo.
Tuy nhiên, hiện tại thì nginx phụ thuộc hoàn toàn vào os mà máy chủ đang dùng. Nếu os có update lên phiên bản mới hoặc các ứng dụng khác trên os cập nhật hoặc bạn cài đặt thêm ứng dụng khác trên os gây xung đột với phiên bản nginx hiện tại thì sẽ ảnh hưởng đến sản phẩm của chúng ta.</description></item></channel></rss>